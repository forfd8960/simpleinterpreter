// Code generated by "enumer -type=TokenType"; DO NOT EDIT.

package tokens

import (
	"fmt"
	"strings"
)

const _TokenTypeName = "ILLEGALEOFIDENTINTEGERSTRINGASSIGNPLUSDPlusDMinusMINUSBANGASTERISKPOWSLASHLTLTEQGTGTEQEQUALNOTEQUALORANDCOMMASEMICOLONDOTLPRARENTRPARENTLBRACERBRACELSQBRACKETRSQBRACKETCLASSTHISFUNCTIONLETIFELSERETURNTRUEFALSENILFORWHILEPRINTBREAK"

var _TokenTypeIndex = [...]uint8{0, 7, 10, 15, 22, 28, 34, 38, 43, 49, 54, 58, 66, 69, 74, 76, 80, 82, 86, 91, 99, 101, 104, 109, 118, 121, 129, 136, 142, 148, 158, 168, 173, 177, 185, 188, 190, 194, 200, 204, 209, 212, 215, 220, 225, 230}

const _TokenTypeLowerName = "illegaleofidentintegerstringassignplusdplusdminusminusbangasteriskpowslashltlteqgtgteqequalnotequalorandcommasemicolondotlprarentrparentlbracerbracelsqbracketrsqbracketclassthisfunctionletifelsereturntruefalsenilforwhileprintbreak"

func (i TokenType) String() string {
	if i < 0 || i >= TokenType(len(_TokenTypeIndex)-1) {
		return fmt.Sprintf("TokenType(%d)", i)
	}
	return _TokenTypeName[_TokenTypeIndex[i]:_TokenTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TokenTypeNoOp() {
	var x [1]struct{}
	_ = x[ILLEGAL-(0)]
	_ = x[EOF-(1)]
	_ = x[IDENT-(2)]
	_ = x[INTEGER-(3)]
	_ = x[STRING-(4)]
	_ = x[ASSIGN-(5)]
	_ = x[PLUS-(6)]
	_ = x[DPlus-(7)]
	_ = x[DMinus-(8)]
	_ = x[MINUS-(9)]
	_ = x[BANG-(10)]
	_ = x[ASTERISK-(11)]
	_ = x[POW-(12)]
	_ = x[SLASH-(13)]
	_ = x[LT-(14)]
	_ = x[LTEQ-(15)]
	_ = x[GT-(16)]
	_ = x[GTEQ-(17)]
	_ = x[EQUAL-(18)]
	_ = x[NOTEQUAL-(19)]
	_ = x[OR-(20)]
	_ = x[AND-(21)]
	_ = x[COMMA-(22)]
	_ = x[SEMICOLON-(23)]
	_ = x[DOT-(24)]
	_ = x[LPRARENT-(25)]
	_ = x[RPARENT-(26)]
	_ = x[LBRACE-(27)]
	_ = x[RBRACE-(28)]
	_ = x[LSQBRACKET-(29)]
	_ = x[RSQBRACKET-(30)]
	_ = x[CLASS-(31)]
	_ = x[THIS-(32)]
	_ = x[FUNCTION-(33)]
	_ = x[LET-(34)]
	_ = x[IF-(35)]
	_ = x[ELSE-(36)]
	_ = x[RETURN-(37)]
	_ = x[TRUE-(38)]
	_ = x[FALSE-(39)]
	_ = x[NIL-(40)]
	_ = x[FOR-(41)]
	_ = x[WHILE-(42)]
	_ = x[PRINT-(43)]
	_ = x[BREAK-(44)]
}

var _TokenTypeValues = []TokenType{ILLEGAL, EOF, IDENT, INTEGER, STRING, ASSIGN, PLUS, DPlus, DMinus, MINUS, BANG, ASTERISK, POW, SLASH, LT, LTEQ, GT, GTEQ, EQUAL, NOTEQUAL, OR, AND, COMMA, SEMICOLON, DOT, LPRARENT, RPARENT, LBRACE, RBRACE, LSQBRACKET, RSQBRACKET, CLASS, THIS, FUNCTION, LET, IF, ELSE, RETURN, TRUE, FALSE, NIL, FOR, WHILE, PRINT, BREAK}

var _TokenTypeNameToValueMap = map[string]TokenType{
	_TokenTypeName[0:7]:          ILLEGAL,
	_TokenTypeLowerName[0:7]:     ILLEGAL,
	_TokenTypeName[7:10]:         EOF,
	_TokenTypeLowerName[7:10]:    EOF,
	_TokenTypeName[10:15]:        IDENT,
	_TokenTypeLowerName[10:15]:   IDENT,
	_TokenTypeName[15:22]:        INTEGER,
	_TokenTypeLowerName[15:22]:   INTEGER,
	_TokenTypeName[22:28]:        STRING,
	_TokenTypeLowerName[22:28]:   STRING,
	_TokenTypeName[28:34]:        ASSIGN,
	_TokenTypeLowerName[28:34]:   ASSIGN,
	_TokenTypeName[34:38]:        PLUS,
	_TokenTypeLowerName[34:38]:   PLUS,
	_TokenTypeName[38:43]:        DPlus,
	_TokenTypeLowerName[38:43]:   DPlus,
	_TokenTypeName[43:49]:        DMinus,
	_TokenTypeLowerName[43:49]:   DMinus,
	_TokenTypeName[49:54]:        MINUS,
	_TokenTypeLowerName[49:54]:   MINUS,
	_TokenTypeName[54:58]:        BANG,
	_TokenTypeLowerName[54:58]:   BANG,
	_TokenTypeName[58:66]:        ASTERISK,
	_TokenTypeLowerName[58:66]:   ASTERISK,
	_TokenTypeName[66:69]:        POW,
	_TokenTypeLowerName[66:69]:   POW,
	_TokenTypeName[69:74]:        SLASH,
	_TokenTypeLowerName[69:74]:   SLASH,
	_TokenTypeName[74:76]:        LT,
	_TokenTypeLowerName[74:76]:   LT,
	_TokenTypeName[76:80]:        LTEQ,
	_TokenTypeLowerName[76:80]:   LTEQ,
	_TokenTypeName[80:82]:        GT,
	_TokenTypeLowerName[80:82]:   GT,
	_TokenTypeName[82:86]:        GTEQ,
	_TokenTypeLowerName[82:86]:   GTEQ,
	_TokenTypeName[86:91]:        EQUAL,
	_TokenTypeLowerName[86:91]:   EQUAL,
	_TokenTypeName[91:99]:        NOTEQUAL,
	_TokenTypeLowerName[91:99]:   NOTEQUAL,
	_TokenTypeName[99:101]:       OR,
	_TokenTypeLowerName[99:101]:  OR,
	_TokenTypeName[101:104]:      AND,
	_TokenTypeLowerName[101:104]: AND,
	_TokenTypeName[104:109]:      COMMA,
	_TokenTypeLowerName[104:109]: COMMA,
	_TokenTypeName[109:118]:      SEMICOLON,
	_TokenTypeLowerName[109:118]: SEMICOLON,
	_TokenTypeName[118:121]:      DOT,
	_TokenTypeLowerName[118:121]: DOT,
	_TokenTypeName[121:129]:      LPRARENT,
	_TokenTypeLowerName[121:129]: LPRARENT,
	_TokenTypeName[129:136]:      RPARENT,
	_TokenTypeLowerName[129:136]: RPARENT,
	_TokenTypeName[136:142]:      LBRACE,
	_TokenTypeLowerName[136:142]: LBRACE,
	_TokenTypeName[142:148]:      RBRACE,
	_TokenTypeLowerName[142:148]: RBRACE,
	_TokenTypeName[148:158]:      LSQBRACKET,
	_TokenTypeLowerName[148:158]: LSQBRACKET,
	_TokenTypeName[158:168]:      RSQBRACKET,
	_TokenTypeLowerName[158:168]: RSQBRACKET,
	_TokenTypeName[168:173]:      CLASS,
	_TokenTypeLowerName[168:173]: CLASS,
	_TokenTypeName[173:177]:      THIS,
	_TokenTypeLowerName[173:177]: THIS,
	_TokenTypeName[177:185]:      FUNCTION,
	_TokenTypeLowerName[177:185]: FUNCTION,
	_TokenTypeName[185:188]:      LET,
	_TokenTypeLowerName[185:188]: LET,
	_TokenTypeName[188:190]:      IF,
	_TokenTypeLowerName[188:190]: IF,
	_TokenTypeName[190:194]:      ELSE,
	_TokenTypeLowerName[190:194]: ELSE,
	_TokenTypeName[194:200]:      RETURN,
	_TokenTypeLowerName[194:200]: RETURN,
	_TokenTypeName[200:204]:      TRUE,
	_TokenTypeLowerName[200:204]: TRUE,
	_TokenTypeName[204:209]:      FALSE,
	_TokenTypeLowerName[204:209]: FALSE,
	_TokenTypeName[209:212]:      NIL,
	_TokenTypeLowerName[209:212]: NIL,
	_TokenTypeName[212:215]:      FOR,
	_TokenTypeLowerName[212:215]: FOR,
	_TokenTypeName[215:220]:      WHILE,
	_TokenTypeLowerName[215:220]: WHILE,
	_TokenTypeName[220:225]:      PRINT,
	_TokenTypeLowerName[220:225]: PRINT,
	_TokenTypeName[225:230]:      BREAK,
	_TokenTypeLowerName[225:230]: BREAK,
}

var _TokenTypeNames = []string{
	_TokenTypeName[0:7],
	_TokenTypeName[7:10],
	_TokenTypeName[10:15],
	_TokenTypeName[15:22],
	_TokenTypeName[22:28],
	_TokenTypeName[28:34],
	_TokenTypeName[34:38],
	_TokenTypeName[38:43],
	_TokenTypeName[43:49],
	_TokenTypeName[49:54],
	_TokenTypeName[54:58],
	_TokenTypeName[58:66],
	_TokenTypeName[66:69],
	_TokenTypeName[69:74],
	_TokenTypeName[74:76],
	_TokenTypeName[76:80],
	_TokenTypeName[80:82],
	_TokenTypeName[82:86],
	_TokenTypeName[86:91],
	_TokenTypeName[91:99],
	_TokenTypeName[99:101],
	_TokenTypeName[101:104],
	_TokenTypeName[104:109],
	_TokenTypeName[109:118],
	_TokenTypeName[118:121],
	_TokenTypeName[121:129],
	_TokenTypeName[129:136],
	_TokenTypeName[136:142],
	_TokenTypeName[142:148],
	_TokenTypeName[148:158],
	_TokenTypeName[158:168],
	_TokenTypeName[168:173],
	_TokenTypeName[173:177],
	_TokenTypeName[177:185],
	_TokenTypeName[185:188],
	_TokenTypeName[188:190],
	_TokenTypeName[190:194],
	_TokenTypeName[194:200],
	_TokenTypeName[200:204],
	_TokenTypeName[204:209],
	_TokenTypeName[209:212],
	_TokenTypeName[212:215],
	_TokenTypeName[215:220],
	_TokenTypeName[220:225],
	_TokenTypeName[225:230],
}

// TokenTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TokenTypeString(s string) (TokenType, error) {
	if val, ok := _TokenTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TokenTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to TokenType values", s)
}

// TokenTypeValues returns all values of the enum
func TokenTypeValues() []TokenType {
	return _TokenTypeValues
}

// TokenTypeStrings returns a slice of all String values of the enum
func TokenTypeStrings() []string {
	strs := make([]string, len(_TokenTypeNames))
	copy(strs, _TokenTypeNames)
	return strs
}

// IsATokenType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i TokenType) IsATokenType() bool {
	for _, v := range _TokenTypeValues {
		if i == v {
			return true
		}
	}
	return false
}
